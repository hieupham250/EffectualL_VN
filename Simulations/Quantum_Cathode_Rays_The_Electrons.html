<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="shortcut icon" href="../files/favicon_white.ico" media="(prefers-color-scheme: dark)" />
    <link rel="shortcut icon" href="../files/favicon.ico" media="(prefers-color-scheme: light)" />
    <link rel="stylesheet" type="text/css" href="../css/style-page.css">
    <title>Cathode Rays-The Electron</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0JWHY29KD2"></script>
<!--     <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-0JWHY29KD2');
    </script> -->
    <meta name="google-site-verification" content="mz0TRB59UNqdTxhwzmXmGdgVPh8pB4YqjuUr-aWNGIY">

</head>

<body>
    <div style="color: beige;" id="topmenu">Cathode Rays-The Electron</div>
    <div id="sidemenu"> </div>


    <div id="menu" style="width: 100%;">
        <button id="switch" style="background-color: red;">OFF</button>
        <button id="volt">High Voltage &#9889</button>
        <button id="polarity"> Change Polarity</button>
    </div>


    <script type="module">

        import * as THREE from '../build/three.module.js';
        import { OrbitControls } from '../jsm/controls/OrbitControls.js';
        import { GLTFLoader } from '../jsm/loaders/GLTFLoader.js';
        import { GUI } from '../jsm/libs/lil-gui.module.min.js';
        import { RGBELoader } from '../jsm/loaders/RGBELoader.js';

        let camera, scene, renderer, stats, controls;
        let labelGeometry = new THREE.PlaneBufferGeometry(2.5, 2.5);
        let electron, t = 0, b = 5;
        let topMaterial, bottomMaterial, onLabel, onMaterial, onButton;
        let voltButton, requestID, voltLabel, voltMaterial, bottomPlate, topPlate;

        let electronTube, electronButton, gunLabel, pulseLabel;
        let power = false;
        let points = [];
        const objects = [];
        let curves = new THREE.Group();
        let LINES = new THREE.Group();
        let magnet = new THREE.Group();
        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector2();
        let SELECTED;

        let pole1, pole2;
        let isChanged = false;
        let isflipped = false
        let redMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
        let blueMaterial = new THREE.MeshPhongMaterial({ color: 0x0000FF });

        let onTexture = new THREE.TextureLoader().load('./assets/img/on.png');
        let offTexture = new THREE.TextureLoader().load('./assets/img/off.png');
        let voltTexture = new THREE.TextureLoader().load('./assets/img/highVolt.png');
        let light = new THREE.MeshPhongMaterial({ color: 'wheat' })
        let greenMaterial = new THREE.MeshPhongMaterial({ color: 'green' });
        const hdrEquirect = new RGBELoader()
            .setPath('./assets/textures/')
            .load('royal_esplanade_1k.hdr', function () {

                hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

                init();
                render();

            });
        let clearMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 1,
            roughness: 0.6,
            ior: 1.5,
            // alphaMap: texture,
            envMap: hdrEquirect,
            thickness: 1,
            envMapIntensity: 1,
            transmission: 1, // use material.transmission for glass materials
            specularIntensity: 1,
            specularColor: 0xffffff,
            opacity: 1,
            side: THREE.DoubleSide,
            transparent: true
        });
        let buttonPolarity = document.getElementById('polarity');
        let buttonVolt = document.getElementById('volt');
        let buttonSwitch = document.getElementById('switch');
        let clock = new THREE.Clock();

        let INTERSECTED


        function init() {

            scene = new THREE.Scene();

            createLights();
            createRenderer();
            createCamera(-40, 0, 40);
            createControls(0, -4, 0);
            createModel();
            electronChamber();
            scene.add(LINES)
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);
            animate()
            LINES.visible = false;

            buttonActions()
        }

        function buttonActions() {

            buttonPolarity.addEventListener('click', function () {
                isflipped = !isflipped
            });

            buttonVolt.addEventListener('click', function () {
                pulseAction()
            });

            buttonSwitch.addEventListener('click', function () {
                power = !power
                gunAction()

            });
        }

        function electronChamber() {
            //labels
            let tubeGeometry = new THREE.CylinderGeometry(.8, .8, 1, 16);
            let elnMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
            let electronLabel = makeText(-24, -1.5, 1.9, 32, elnMaterial, 'ELECTRON GUN', "rgba(0, 0, 0, 0.1)", "rgba(0, 255, 255, 1)");
            electronButton = new THREE.Mesh(tubeGeometry, redMaterial);
            voltButton = electronButton.clone()

            let voltGeometry = new THREE.PlaneGeometry(4, 2)
            voltLabel = new THREE.Mesh(voltGeometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, map: offTexture, transparent: true }));
            voltLabel.position.set(-13, -8.9, 5)
            voltLabel.rotation.x = -1.57
            scene.add(voltLabel)

            voltLabel.add(voltButton)
            voltButton.rotation.set(1.57, 0, 0)
            voltButton.position.set(-1.1, 0, 0)
            objects.push(voltButton, voltLabel)

            let gunGeometry = new THREE.PlaneGeometry(4, 2);
            gunLabel = new THREE.Mesh(gunGeometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, map: offTexture, transparent: true }));
            scene.add(gunLabel)
            gunLabel.position.set(-24, 0, 1.9)
            gunLabel.add(electronButton)
            electronButton.rotation.x = 1.57
            electronButton.position.set(-1.1, 0, 0)
            objects.push(electronButton, gunLabel)

            let powerMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
            let powerabel = makeText(-10, -12, 7, 32, powerMaterial, 'HIGH VOLTAGE SUPPLY ', "rgba(0, 0, 0, 0.1)", "rgba(0, 255, 255, 1)");

            let pulseGeometry = new THREE.PlaneGeometry(2, 2.5);
            pulseLabel = new THREE.Mesh(pulseGeometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, map: voltTexture, transparent: true }));
            scene.add(pulseLabel)
            pulseLabel.position.set(-3, 10, 1.9)
            pulseLabel.visible = false

            let voltMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
            let plateLabel = makeText(-5, 7, 2, 32, voltMaterial, 'VOLTAGE PLATES', "rgba(0, 0, 0, 0.1)", "rgba(0, 255, 255, 1)");
            topMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
            let posLabel = makeText(-1, 6, 0, 92, topMaterial, '   ', "rgba(0, 0, 0, 0)", "rgba(0, 255, 255, 1)");
            bottomMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true });
            let negLabel = makeText(-1, -6, 0, 92, bottomMaterial, '   ', "rgba(0, 0, 0, 0)", "rgba(0, 255, 255, 1)");
        }

        function createModel() {

            const loader = new GLTFLoader();

            loader
                .setPath('./model/')
                .load('chamber.glb', function (gltf) {
                    let model = gltf.scene;
                    // model.scale.set(10, 10, 10);
                    // console.log(model)
                    pole1 = model.getObjectByName('pole1');
                    pole2 = model.getObjectByName('pole2');
                    let gun = model.getObjectByName('gun');
                    electronTube = model.getObjectByName('electrontube');

                    let platetop = model.getObjectByName('platetop');
                    let platebottom = model.getObjectByName('platebottom');
                    let chamber = model.getObjectByName('chamber');
                    let supply = model.getObjectByName('supply');
                    chamber.material = clearMaterial;
                    platetop.material = blueMaterial;
                    platebottom.material = redMaterial;
                    pole1.visible = isChanged;
                    pole2.visible = isChanged;
                    scene.add(model);

                    // model.position.set(4, 0, 0)
                    electronTube.position.x = -23
                    gun.position.x = -13.5
                });


        }

        function addSphere(r, N, mat) {
            let material = mat
            let geometry = new THREE.SphereGeometry(r, N);
            let mesh = new THREE.Mesh(geometry, material);
            return mesh
        }

        function pointerMove() {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

        }

        function onClick(event) {
            event.preventDefault();
            pointerMove()
            raycaster.setFromCamera(pointer, camera);
            let intersects = raycaster.intersectObjects(objects, true);
            if (intersects.length > 0) {

                SELECTED = intersects[0].object;// electronButton, gunLabel
                if (SELECTED == gunLabel || SELECTED == electronButton || SELECTED == electronTube) {
                    // console.log(SELECTED, 'on', power)
                    power = !power
                    gunAction()
                }
                if (SELECTED == voltLabel || SELECTED == voltButton) {
                    // console.log(SELECTED, 'on')
                    pulseAction()

                }
            }
        }

        function pulseAction() {
            voltLabel.material.map = onTexture
            voltButton.position.set(1.1, 0, 0)
            voltButton.material = greenMaterial

            pulseLabel.visible = true
            points = []
            t = 0;
            if (isflipped) {
                let posCanvas = makeLabelCanvas(52, ' - ', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                topMaterial.map = new THREE.CanvasTexture(posCanvas);
                let negCanvas = makeLabelCanvas(52, ' + ', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                bottomMaterial.map = new THREE.CanvasTexture(negCanvas);
                curvePath()
            } else {
                let posCanvas = makeLabelCanvas(52, ' +', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                topMaterial.map = new THREE.CanvasTexture(posCanvas);
                let negCanvas = makeLabelCanvas(52, ' - ', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                bottomMaterial.map = new THREE.CanvasTexture(negCanvas);
                curvePath1()
            }
            setTimeout(function () {
                voltLabel.material.map = offTexture
                voltButton.position.set(-1.1, 0, 0)
                voltButton.material = redMaterial
                let posCanvas = makeLabelCanvas(52, '  ', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                topMaterial.map = new THREE.CanvasTexture(posCanvas);
                let negCanvas = makeLabelCanvas(52, '  ', "rgba(0, 1, 0, 0)", "rgba(0, 255, 255, 1)");
                bottomMaterial.map = new THREE.CanvasTexture(negCanvas);
                pulseLabel.visible = false
                points = []
                t = 0;
                addPath()

            }, 1500);
        }

        function gunAction() {
            if (power) {
                buttonSwitch.style.backgroundColor = "green"
                buttonSwitch.innerHTML = "ON"
                gunLabel.material.map = onTexture
                electronButton.position.set(1.1, 0, 0)
                electronButton.material = greenMaterial
                points = []
                t = 0;
                addPath()
                LINES.visible = true;
            } else if (!power) {
                buttonSwitch.style.backgroundColor = "red"
                buttonSwitch.innerHTML = "OFF"
                gunLabel.material.map = offTexture
                electronButton.position.set(-1.1, 0, 0)
                electronButton.material = redMaterial
                LINES.visible = false;
            }
        }

        function addPath() {
            while (LINES.children.length > 0) {
                const A = LINES.children[0];
                A.parent.remove(A);
            }
            let vertices = [];
            // let points = [];
            const point = new THREE.Vector3();
            const color = new THREE.Color();
            for (let i = 0; i < 33; i = i + 0.1) {
                // let v = new THREE.Vector3(-13 + 12 * i, -(i * i), 0)
                // points.push(v)
                //parabola Ax^2 - By^2 = C new THREE.Vector3(Math.pow(((i * i) + 13), (i * i), 0.5), 0) 
                // new THREE.Vector3(r * Math.cos(i * theta), r * Math.sin(i * theta), 0).add(new THREE.Vector3(b, 0, 0)) new THREE.Vector3(-13 + i, 0, 0)
                let v = new THREE.Vector3(15 - i, 0, 0)
                points.push(v)


            }
            const geometry = new THREE.BufferGeometry();

            let colors = [];

            for (let i = 0; i < points.length; i++) {

                const point = points[i];
                vertices.push(point.x, point.y, point.z);
                color.setHSL(1, 1, Math.max(0, (20 - points[i].x) / 20) * 0.5, THREE.SRGBColorSpace);
                colors.push(color.r, color.g, color.b);

            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true });

            let line, p;
            const scale = 0.7, d = 0;

            const parameters = [
                [material, scale * 1.5, [0, 0, 0], geometry],

            ];

            for (let i = 0; i < parameters.length; i++) {

                p = parameters[i];
                line = new THREE.Line(p[3], p[0]);
                line.scale.x = line.scale.y = line.scale.z = p[1];
                line.position.x = p[2][0];
                line.position.y = p[2][1];
                line.position.z = p[2][2];
                scene.add(line);

            }
            LINES.add(line);
        }

        function curvePath() {
            while (LINES.children.length > 0) {
                const A = LINES.children[0];
                A.parent.remove(A);
            }
            let vertices = [];
            // let points = [];
            const point = new THREE.Vector3();
            const color = new THREE.Color();
            for (let i = 0; i < 33; i = i + 0.1) {
                let v = new THREE.Vector3(-13 + 12 * i, -(i * i), 0)
                points.push(v)

            }
            const geometry = new THREE.BufferGeometry();

            let colors = [];

            for (let i = 0; i < points.length; i++) {

                const point = points[i];
                vertices.push(point.x, point.y, point.z);
                color.setHSL(1, 1, Math.max(0, (20 - points[i].x) / 20) * 0.5, THREE.SRGBColorSpace);
                colors.push(color.r, color.g, color.b);

            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true });

            let line, p;
            const scale = 0.7, d = 0;

            const parameters = [
                [material, scale * 1.5, [0, 0, 0], geometry],

            ];

            for (let i = 0; i < parameters.length; i++) {

                p = parameters[i];
                line = new THREE.Line(p[3], p[0]);
                line.scale.x = line.scale.y = line.scale.z = p[1];
                line.position.x = p[2][0];
                line.position.y = p[2][1];
                line.position.z = p[2][2];
                scene.add(line);

            }
            LINES.add(line);
        }

        function curvePath1() {
            while (LINES.children.length > 0) {
                const A = LINES.children[0];
                A.parent.remove(A);
            }
            let vertices = [];
            // let points = [];
            const point = new THREE.Vector3();
            const color = new THREE.Color();
            for (let i = 0; i < 33; i = i + 0.1) {
                let v = new THREE.Vector3(-13 + 12 * i, (i * i), 0)
                points.push(v)

            }
            const geometry = new THREE.BufferGeometry();

            let colors = [];

            for (let i = 0; i < points.length; i++) {

                const point = points[i];
                vertices.push(point.x, point.y, point.z);
                color.setHSL(1, 1, Math.max(0, (20 - points[i].x) / 20) * 0.5, THREE.SRGBColorSpace);
                colors.push(color.r, color.g, color.b);

            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true });

            let line, p;
            const scale = 0.7, d = 0;

            const parameters = [
                [material, scale * 1.5, [0, 0, 0], geometry],

            ];

            for (let i = 0; i < parameters.length; i++) {

                p = parameters[i];
                line = new THREE.Line(p[3], p[0]);
                line.scale.x = line.scale.y = line.scale.z = p[1];
                line.position.x = p[2][0];
                line.position.y = p[2][1];
                line.position.z = p[2][2];
                scene.add(line);

            }
            LINES.add(line);
        }

        function createCamera(x, y, z) {

            let fov = 55;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1500;

            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

            camera.position.set(x, y, z);
        }

        function createControls(x, y, z) {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.target.set(x, y, z);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.1;
            controls.update();
            controls.addEventListener('change', render);
        }

        function createRenderer() {
            // create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.alpha = true;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

        }

        function createLights() {
            let hemiLight = new THREE.AmbientLight(0xffffff, .20);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            let dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(0, 10, 0);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 70;
            dirLight.shadow.camera.bottom = -70;
            dirLight.shadow.camera.left = -70
            dirLight.shadow.camera.right = 70;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            scene.add(new THREE.AmbientLight(0xffffff, .4));
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update()
            render();

        }

        function render() {
            renderer.render(scene, camera);
        }

        function guiControls() {
            let gui = new GUI();
            gui.close()


            gui.add(camera.position, 'x', -100, 100);
            gui.add(camera.position, 'y', -100, 100);
            gui.add(camera.position, 'z', -100, 100);
            let controlFolder = gui.addFolder("Control");
            controlFolder.add(controls.target, 'x', -100, 100);
            controlFolder.add(controls.target, 'y', -100, 100);
            controlFolder.add(controls.target, 'z', -100, 100);

        }

        function makeLabelCanvas(size, name, backgdCol, color) {
            const borderSize = 2;
            const ctx = document.createElement('canvas').getContext('2d');
            const font = `${size}px bold sans-serif`;
            ctx.font = font;
            // measure how long the name will be
            const doubleBorderSize = borderSize * 2;
            const width = ctx.measureText(name).width + doubleBorderSize;
            const height = size + doubleBorderSize;
            ctx.canvas.width = width;
            ctx.canvas.height = height;

            // need to set font again after resizing canvas
            ctx.font = font;
            ctx.textBaseline = 'top';

            ctx.fillStyle = backgdCol;
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = color;
            ctx.fillText(name, borderSize, borderSize);

            return ctx.canvas;
        }

        function makeText(x, y, z, size, material, name, backgdCol, color) {
            const canvas = makeLabelCanvas(size, name, backgdCol, color);
            material.map = new THREE.CanvasTexture(canvas);

            const root = new THREE.Object3D();
            root.position.set(x, y, z);

            const label = new THREE.Mesh(labelGeometry, material);
            root.add(label);
            const labelBaseScale = 0.01;
            label.scale.x = canvas.width * labelBaseScale;
            label.scale.y = canvas.height * labelBaseScale;

            scene.add(root);
            return root;
        }


        function generateTexture() {

            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;

            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 1, 2, 1);

            return canvas;

        }

    </script>

</body>

</html>
