import{r as d}from"./index-871a1683.js";import{a3 as g,M as y,a4 as M,K as I,n as f,Q as S,O as E,k as R,m as O,l as x,a5 as m}from"./XR-3a18f114.js";import{G as F}from"./GLTFLoader-6513b2d7.js";var L=Object.defineProperty,U=(s,e,t)=>e in s?L(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,u=(s,e,t)=>(U(s,typeof e!="symbol"?e+"":e,t),t);const h={Handedness:{NONE:"none",LEFT:"left",RIGHT:"right"},ComponentState:{DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"},ComponentProperty:{BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"},ComponentType:{TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"},ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:{TRANSFORM:"transform",VISIBILITY:"visibility"}};async function P(s){const e=await fetch(s);if(e.ok)return e.json();throw new Error(e.statusText)}async function _(s){if(!s)throw new Error("No basePath supplied");return await P(`${s}/profilesList.json`)}async function $(s,e,t=null,a=!0){if(!s)throw new Error("No xrInputSource supplied");if(!e)throw new Error("No basePath supplied");const i=await _(e);let l;if(s.profiles.some(o=>{const c=i[o];return c&&(l={profileId:o,profilePath:`${e}/${c.path}`,deprecated:!!c.deprecated}),!!l}),!l){if(!t)throw new Error("No matching profile name found");const o=i[t];if(!o)throw new Error(`No matching profile name found and default profile "${t}" missing.`);l={profileId:t,profilePath:`${e}/${o.path}`,deprecated:!!o.deprecated}}const n=await P(l.profilePath);let r;if(a){let o;if(s.handedness==="any"?o=n.layouts[Object.keys(n.layouts)[0]]:o=n.layouts[s.handedness],!o)throw new Error(`No matching handedness, ${s.handedness}, in profile ${l.profileId}`);o.assetPath&&(r=l.profilePath.replace("profile.json",o.assetPath))}return{profile:n,assetPath:r}}const B={xAxis:0,yAxis:0,button:0,state:h.ComponentState.DEFAULT};function G(s=0,e=0){let t=s,a=e;if(Math.sqrt(s*s+e*e)>1){const n=Math.atan2(e,s);t=Math.cos(n),a=Math.sin(n)}return{normalizedXAxis:t*.5+.5,normalizedYAxis:a*.5+.5}}class k{constructor(e){u(this,"value"),u(this,"componentProperty"),u(this,"states"),u(this,"valueNodeName"),u(this,"valueNodeProperty"),u(this,"minNodeName"),u(this,"maxNodeName"),u(this,"valueNode"),u(this,"minNode"),u(this,"maxNode"),this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===h.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(B)}updateFromComponent({xAxis:e,yAxis:t,button:a,state:i}){const{normalizedXAxis:l,normalizedYAxis:n}=G(e,t);switch(this.componentProperty){case h.ComponentProperty.X_AXIS:this.value=this.states.includes(i)?l:.5;break;case h.ComponentProperty.Y_AXIS:this.value=this.states.includes(i)?n:.5;break;case h.ComponentProperty.BUTTON:this.value=this.states.includes(i)&&a?a:0;break;case h.ComponentProperty.STATE:this.valueNodeProperty===h.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(i):this.value=this.states.includes(i)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class H{constructor(e,t){if(u(this,"id"),u(this,"values"),u(this,"type"),u(this,"gamepadIndices"),u(this,"rootNodeName"),u(this,"visualResponses"),u(this,"touchPointNodeName"),u(this,"touchPointNode"),!e||!t||!t.visualResponses||!t.gamepadIndices||Object.keys(t.gamepadIndices).length===0)throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach(a=>{const i=new k(t.visualResponses[a]);this.visualResponses[a]=i}),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:h.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=h.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||this.values.button===1?this.values.state=h.ComponentState.PRESSED:(t.touched||this.values.button>h.ButtonTouchThreshold)&&(this.values.state=h.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===h.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>h.AxisTouchThreshold&&(this.values.state=h.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===h.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>h.AxisTouchThreshold&&(this.values.state=h.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(t=>{t.updateFromComponent(this.values)})}}class V{constructor(e,t,a){if(u(this,"xrInputSource"),u(this,"assetUrl"),u(this,"layoutDescription"),u(this,"id"),u(this,"components"),!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");if(!t.layouts[e.handedness])throw new Error("No layout for "+e.handedness+" handedness");this.xrInputSource=e,this.assetUrl=a,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(i=>{const l=this.layoutDescription.components[i];this.components[i]=new H(i,l)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach(t=>{e.push(t.data)}),e}updateFromGamepad(){Object.values(this.components).forEach(e=>{e.updateFromGamepad(this.xrInputSource.gamepad)})}}const j="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",X="generic-trigger";class z{constructor(e=null,t=j){this.gltfLoader=e??new F,this.path=t,this._assetCache={}}initializeControllerModel(e,t){return t.targetRayMode!=="tracked-pointer"||!t.gamepad?Promise.resolve():$(t,this.path,X).then(({profile:a,assetPath:i})=>{if(!i)throw new Error("no asset path");const l=new V(t,a,i);e.connectMotionController(l);const n=l.assetUrl,r=this._assetCache[n];if(r){const o=r.scene.clone();e.connectModel(o)}else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(n,o=>{if(!e.motionController){console.warn("motionController gone while gltf load, bailing...");return}this._assetCache[n]=o;const c=o.scene.clone();e.connectModel(c)},void 0,()=>{throw new Error(`Asset ${n} missing or malformed.`)})}}).catch(a=>{console.warn(a)})}}const A=s=>"envMap"in s,C=(s,e)=>{s.envMap=e,s.needsUpdate=!0},b=(s,e)=>{e instanceof y&&(Array.isArray(e.material)?e.material.forEach(t=>A(t)?C(t,s):void 0):A(e.material)&&C(e.material,s))},w=s=>"envMapIntensity"in s,T=(s,e)=>{s.envMapIntensity=e,s.needsUpdate=!0},v=(s,e)=>{e instanceof y&&(Array.isArray(e.material)?e.material.forEach(t=>w(t)?T(t,s):void 0):w(e.material)&&T(e.material,s))};function D(s,e){Object.values(s.components).forEach(t=>{const{type:a,touchPointNodeName:i,visualResponses:l}=t;if(a===h.ComponentType.TOUCHPAD&&i)if(t.touchPointNode=e.getObjectByName(i),t.touchPointNode){const n=new M(.001),r=new I({color:255}),o=new y(n,r);t.touchPointNode.add(o)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(l).forEach(n=>{const{valueNodeName:r,minNodeName:o,maxNodeName:c,valueNodeProperty:p}=n;if(p===h.VisualResponseProperty.TRANSFORM&&o&&c){if(n.minNode=e.getObjectByName(o),n.maxNode=e.getObjectByName(c),!n.minNode){console.warn(`Could not find ${o} in the model`);return}if(!n.maxNode){console.warn(`Could not find ${c} in the model`);return}}n.valueNode=e.getObjectByName(r),n.valueNode||console.warn(`Could not find ${r} in the model`)})})}function Y(s,e){D(s.motionController,e),(s.envMap||s.envMapIntensity!=null)&&e.traverse(t=>{s.envMap&&b(s.envMap,t),s.envMapIntensity!=null&&v(s.envMapIntensity,t)}),s.add(e)}class q extends g{constructor(){super(),this.motionController=null,this.envMap=null,this.envMapIntensity=1,this.scene=null}setEnvironmentMap(e,t=1){var a;return this.envMap===e&&this.envMapIntensity===t?this:(this.envMap=e,this.envMapIntensity=t,(a=this.scene)==null||a.traverse(i=>{b(e,i),v(t,i)}),this)}setEnvironmentMapIntensity(e){var t;return this.envMapIntensity===e?this:(this.envMapIntensity=e,(t=this.scene)==null||t.traverse(a=>v(e,a)),this)}connectModel(e){if(!this.motionController){console.warn("scene tried to add, but no motion controller");return}this.scene=e,Y(this,e),this.dispatchEvent({type:"modelconnected",data:e})}connectMotionController(e){this.motionController=e,this.dispatchEvent({type:"motionconnected",data:e})}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(t=>{Object.values(t.visualResponses).forEach(a=>{const{valueNode:i,minNode:l,maxNode:n,value:r,valueNodeProperty:o}=a;i&&(o===h.VisualResponseProperty.VISIBILITY&&typeof r=="boolean"?i.visible=r:o===h.VisualResponseProperty.TRANSFORM&&l&&n&&typeof r=="number"&&(i.quaternion.slerpQuaternions(l.quaternion,n.quaternion,r),i.position.lerpVectors(l.position,n.position,r)))})}))}disconnect(){this.dispatchEvent({type:"motiondisconnected",data:this.motionController}),this.dispatchEvent({type:"modeldisconnected",data:this.scene}),this.motionController=null,this.scene&&this.remove(this.scene),this.scene=null}dispose(){this.disconnect()}}const Q=d.forwardRef(function({target:e,hideOnBlur:t=!1,...a},i){const l=f(o=>o.hoverState),n=d.useRef(null),r=d.useMemo(()=>new S().setFromPoints([new E(0,0,0),new E(0,0,-1)]),[]);return d.useImperativeHandle(i,()=>n.current),R(()=>{if(!e.inputSource)return;let o=1;const c=l[e.inputSource.handedness].values().next().value;c&&e.inputSource.handedness!=="none"?(o=c.distance,t&&(n.current.visible=!1)):t&&(n.current.visible=!0);const p=-.01;n.current.scale.z=o+p}),d.createElement("line",{ref:n,geometry:r,"material-opacity":.8,"material-transparent":!0,...a})}),J=new z,K=({target:s,envMap:e,envMapIntensity:t})=>{const a=d.useRef(null),i=m(o=>{e!=null&&o.setEnvironmentMap(e)}),l=m(o=>o.setEnvironmentMap(null)),n=m(o=>{t!=null&&o.setEnvironmentMapIntensity(t)}),r=d.useCallback(o=>{var c,p,N;if(a.current=o,o){if(s.xrControllerModel=o,(c=s.inputSource)!=null&&c.hand)return;i.current(o),n.current(o),s.inputSource?J.initializeControllerModel(o,s.inputSource):console.warn("no input source on XRController when handleControllerModel")}else{if((p=s.inputSource)!=null&&p.hand)return;(N=s.xrControllerModel)==null||N.disconnect(),s.xrControllerModel=null}},[s,n,i]);return d.useLayoutEffect(()=>{a.current&&(e?i.current(a.current):l.current(a.current))},[e,i,l]),d.useLayoutEffect(()=>{a.current&&n.current(a.current)},[t,n]),d.createElement("xRControllerModel",{ref:r})};function te({rayMaterial:s={},hideRaysOnBlur:e=!1,envMap:t,envMapIntensity:a}){const i=f(r=>r.controllers),l=f(r=>r.isHandTracking),n=d.useMemo(()=>Object.entries(s).reduce((r,[o,c])=>({...r,[`material-${o}`]:c}),{}),[JSON.stringify(s)]);return d.useMemo(()=>O({XRControllerModel:q}),[]),d.createElement(d.Fragment,null,i.map((r,o)=>d.createElement(d.Fragment,{key:o},x(d.createElement(K,{target:r,envMap:t,envMapIntensity:a}),r.grip),x(d.createElement(Q,{visible:!l,hideOnBlur:e,target:r,...n}),r.controller))))}export{te as C};
